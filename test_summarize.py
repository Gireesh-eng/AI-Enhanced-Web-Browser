import sys
import os
from PyQt5.QtCore import QCoreApplication, QTimer, QObject, pyqtSignal
from PyQt5.QtWebEngineWidgets import QWebEnginePage # Dummy for GeminiHelper
from utils.gemini_helper import GeminiHelper

# Ensure Python can find modules in the 'utils' directory
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '.')))

# Long sample text for testing summarization
LONG_TEXT = """
Natural language processing (NLP) is a subfield of linguistics, computer science, and artificial intelligence
concerned with the interactions between computers and human language, in particular how to program computers
to process and analyze large amounts of natural language data. The goal is a computer capable of
"understanding" the contents of documents, including the contextual nuances of the language within them.
The technology can then accurately extract information and insights contained in the documents as well as
categorize and organize the documents themselves. Challenges in natural language processing frequently
involve speech recognition, natural language understanding, and natural language generation.

NLP has a wide range of applications in various fields. One of the most common applications is machine
translation, where systems like Google Translate or DeepL use NLP techniques to translate text from one
language to another. Another significant application is sentiment analysis, which involves determining
the sentiment expressed in a piece of text, whether it's positive, negative, or neutral. This is widely
used in social media monitoring, customer feedback analysis, and market research.

Information retrieval (IR) is also closely related to NLP. Search engines like Google and Bing use NLP
to understand user queries and retrieve relevant documents from the web. NLP techniques such as stemming,
lemmatization, and named entity recognition are crucial for effective IR. Furthermore, NLP powers
chatbots and virtual assistants like Siri, Alexa, and Google Assistant, enabling them to understand
user commands and respond in a human-like manner.

Text summarization, the task this test focuses on, is another key NLP application. It involves creating
a concise and fluent summary of a longer text document. This can be either extractive, where important
sentences are selected from the original text, or abstractive, where the summary is generated by
paraphrasing and rephrasing the original content. Abstractive summarization is more complex but often
produces more human-like summaries.

Other applications include text generation, question answering, speech recognition, and optical character
recognition. As the amount of textual data continues to grow exponentially, the importance of NLP and its
applications will only increase. Researchers are constantly working on developing more advanced NLP models,
often leveraging deep learning techniques, to tackle more complex language understanding and generation tasks.
The development of large language models (LLMs) like GPT-3 and BERT has marked a significant milestone
in the field, demonstrating remarkable capabilities in various NLP tasks. These models are trained on vast
amounts of text data and can generate coherent and contextually relevant text, translate languages, answer
questions, and much more with unprecedented accuracy. The ethical implications of such powerful technology
are also an active area of research and discussion.
""" * 5 # Make it even longer to ensure it takes time

class GeminiTestRunner(QObject):
    def __init__(self, app):
        super().__init__()
        self.app = app
        self.helper = GeminiHelper()
        self.helper.result_ready.connect(self.on_result_ready)
        self.web_page_dummy = QWebEnginePage() # Dummy object

        # Start a 60-second timer to check if the 30-second timeout was removed
        self.overall_timer = QTimer()
        self.overall_timer.setSingleShot(True)
        self.overall_timer.timeout.connect(self.overall_timeout)
        self.overall_timer.start(60000) # 60 seconds

        print("Starting summarization test with current API key...")
        # Simulate what the main application would do, but without a real webpage
        # For process_with_gemini, the web_page argument is used to run JavaScript.
        # Since we are directly providing content, we can pass a dummy QWebEnginePage.
        # We will need to adapt _handle_content or related methods if direct content input
        # is not supported without JS extraction.
        # For now, let's assume we can bypass the JS extraction for this test
        # by directly calling a method that handles content.

        # Looking at GeminiHelper, _handle_content is called with JS result.
        # We need to call process_with_gemini, which then calls _handle_content.
        # The JS extraction is the first step in process_with_gemini.
        # To test the Gemini call itself, we might need to mock the JS part
        # or, more simply, ensure _handle_content can be called somewhat directly.

        # The current GeminiHelper structure:
        # process_with_gemini -> runJavaScript -> _handle_content -> _summarize_with_gemini
        # We need to ensure the web_page.runJavaScript part can be handled.
        # A simple way is to ensure it calls the callback with our desired content.

        # Let's try to directly call _handle_content for simplicity,
        # bypassing the JavaScript execution part for this specific test.
        # This requires a slight refactor or a test-specific path.
        # Given the tools, refactoring is out. So, let's try to make web_page.runJavaScript work.
        # The callback to runJavaScript is `self._handle_content`.
        # We need `runJavaScript` to call `_handle_content` with our `LONG_TEXT`.

        # Mocking QWebEnginePage's runJavaScript for the test:
        def mock_run_javascript(script, callback):
            print("Mocked runJavaScript called.")
            # Construct the JSON string that _handle_content expects
            data_to_pass = {
                "content": LONG_TEXT,
                "metadata": {"title": "Test Page", "url": "test.com", "language": "en"}
            }
            import json
            callback(json.dumps(data_to_pass))

        self.web_page_dummy.runJavaScript = mock_run_javascript
        
        print(f"GEMINI_API_KEY used: {self.helper.api_key}")
        if not self.helper.api_key or "your-api-key" in self.helper.api_key.lower() or len(self.helper.api_key) < 10:
            print("API Key appears invalid before starting. Emitting error locally.")
            self.on_result_ready("summarize", "Error: API key is missing or invalid based on initial check.")
        else:
            self.helper.process_with_gemini(self.web_page_dummy, 'summarize')


    def on_result_ready(self, action, result):
        print(f"Action: {action}")
        print(f"Result:\n{result}")
        if "timed out after 30 seconds" in result:
            print("TEST FAILED: 30-second timeout message detected.")
        elif "Error: API key" in result:
            print("API Key error detected as expected by test logic.")
        elif action == 'summarize' and "Error:" not in result:
            print("TEST PASSED (Summarization successful or non-timeout error).")
        
        self.overall_timer.stop() # Stop the 60s timer, as we got a result
        self.app.quit()

    def overall_timeout(self):
        print("TEST PASSED: 60-second timer expired, meaning no 30-second timeout occurred.")
        self.app.quit()

if __name__ == '__main__':
    app = QCoreApplication(sys.argv)
    runner = GeminiTestRunner(app)
    sys.exit(app.exec_())
